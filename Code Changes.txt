The transition from the Phase 1 implementation (MO1) to the Phase 2 implementation (MO2) was largely influenced by a change in the development team. 

Person who mainly coded  MO2 opted to bring in his  own implementation of MO1 to address the debugging challenges and  constraints of the original system. 
While the Phase 1 design met its  goals, the tightly coupled dependencies between critical components like the Scheduler, MainConsole, and ConsoleManager created significant hurdles during debugging.
Integrating advanced features required for Phase 2, particularly memory management and paging algorithms, proved impractical without substantial modifications to the Phase 1 architecture.

Debugging challenges in the original Phase 1 design led to inefficiencies that obstructed progress. The rigid inheritance structure from AConsole made it difficult to adapt components like the Scheduler and MainConsole to accommodate memory management seamlessly. Recognizing this, the developer responsible for MO2 decided to start afresh by creating a new branch and re-implementing the Phase 1 functionalities with adjustments tailored to Phase 2 requirements. This decision allowed the developer to focus on building a scalable and modular framework from the outset, bypassing the debugging bottlenecks encountered in the original Phase 1 code.

The drastic overhaul involved reworking key components such as the Scheduler, MemoryManager, and ProcessConsole to better handle the complexities of memory allocation and process management. Changes were made not only to the underlying logic but also to the flow of interaction between the components. For instance, the introduction of modular memory allocators (FlatAllocator and PagingAllocator) required restructuring the MainConsole and Scheduler to ensure seamless integration. These adjustments addressed the errors and inefficiencies of the original Phase 1 design, creating a foundation that was both robust and extensible.

While the commit history clearly demonstrates a departure from the original Phase 1 implementation, it is important to note that the changes were not arbitrary. The developer responsible for MO2 had already devised a logistical framework for implementing Phase 2, which necessitated these modifications. By starting from scratch, the developer ensured that the new design minimized the risks of debugging delays and architectural limitations. This approach allowed Phase 2 requirements, such as advanced memory visualization (process-smi and vmstat commands), to be implemented effectively without being hindered by the constraints of the initial Phase 1 code.
